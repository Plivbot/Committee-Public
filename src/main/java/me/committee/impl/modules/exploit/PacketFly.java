package me.committee.impl.modules.exploit;

import me.committee.api.eventsystem.annotation.EventSubscribe;
import me.committee.api.module.Module;
import me.committee.api.setting.Setting;
import me.committee.api.util.MathUtil;
import me.committee.api.util.MessageSendHelper;
import me.committee.api.util.PacketUtil;
import me.committee.impl.event.events.input.MoveEvent;
import me.committee.impl.event.events.network.ReceivePacketEvent;
import me.committee.impl.event.events.network.SendPacketEvent;
import me.committee.impl.event.events.player.PlayerUpdateEvent;
import net.minecraft.client.gui.GuiDownloadTerrain;
import net.minecraft.network.play.client.CPacketConfirmTeleport;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.network.play.server.SPacketPlayerPosLook;
import net.minecraft.util.math.BlockPos;

public class PacketFly extends Module {

    private final Setting<Mode> modeSetting = new Setting<>("Mode", "Sets the mode of the module", Mode.NEG_CLIP_1);
    private final Setting<Boolean> antiKick = new Setting<>("AntiKick", new String[]{"NoKick"}, "Floats down slowly to prevent the server from kicking the player", true);
    private final Setting<Float> speed = new Setting<>("Speed", "How fast u go retard", 0.2f);

    public PacketFly() {
        super("PacketFly", new String[]{}, "Allows you to do weird movement stuff", Category.EXPLOIT);
    }

    // todo: 9b9t phase (different module but these are the values to start with)
    // final float[] positions = {0.1f, -5f, 0.3f, -1338f, 10f};


    int teleportID = 0;

    @Override
    public void onEnable() {
        super.onEnable();

        if (mc.world != null) {
            this.teleportID = 0;
            PacketUtil.sendPacketNoEvent(new CPacketPlayer.Position(mc.player.posX, -1337, mc.player.posZ, mc.player.onGround));
        }

    }

    @EventSubscribe
    public void onUpdate(PlayerUpdateEvent event) {
        if (modeSetting.getValue() == Mode.NEG_CLIP_1) {
            if (this.teleportID <= 0) {
                PacketUtil.sendPacketNoEvent(new CPacketPlayer.Position(mc.player.posX, -1337, mc.player.posZ, false));
            }

            mc.player.setVelocity(0, 0, 0);

            if (!mc.world.getCollisionBoxes(mc.player, mc.player.getEntityBoundingBox().expand(-0.0625d, 0, -0.0625d)).isEmpty())
                return;

            final double ySpeed =
                    mc.gameSettings.keyBindJump.isKeyDown() ? (this.antiKick.getValue() ? mc.player.ticksExisted % 20 == 0 ? -0.04d : 0.062d : 0.062d) : // Trying to move Up
                    mc.gameSettings.keyBindSneak.isKeyDown() ? -0.062d : // Trying to move Down
                    mc.player.ticksExisted % 4 == 0 ? (this.antiKick.getValue() ? -0.04d : 0.0d) : 0.0d; // Trying to not move

            final double[] coordinates = MathUtil.directionSpeed(speed.getValue());

            if (this.playerIsMoving()) {
                if (coordinates[0] != 0 || coordinates[1] != 0 || ySpeed != 0) {
                    if (mc.player.movementInput.jump && (mc.player.moveStrafing != 0 || mc.player.moveForward != 0)) {
                        mc.player.setVelocity(0, 0, 0);
                        this.packetMove(0, 0, 0);
                        for (int i = 0; i <= 3; i++) {
                            mc.player.setVelocity(0, ySpeed * i, 0);
                            this.packetMove(0, ySpeed * i, 0);
                        }
                    } else {
                        if (mc.player.movementInput.jump) {
                            mc.player.setVelocity(0, 0, 0);
                            this.packetMove(0, 0, 0);
                            for (int i = 0; i <= 3; i++) {
                                mc.player.setVelocity(0, ySpeed * i, 0);
                                this.packetMove(0, ySpeed * i, 0);
                            }
                        } else {
                            for (int i = 0; i <= 2; i++) {
                                mc.player.setVelocity(coordinates[0] * i, ySpeed * i, coordinates[1] * i);
                                this.packetMove(coordinates[0] * i, ySpeed * i, coordinates[1] * i);
                            }
                        }
                    }
                }
            } else {
                if (this.antiKick.getValue()) {
                    if (mc.world.getCollisionBoxes(mc.player, mc.player.getEntityBoundingBox().expand(-0.0625d, -0.0625d, -0.0625d)).isEmpty()) {
                        final float yChange = (mc.player.ticksExisted % 2 == 0) ? 0.04f : -0.04f;
                        mc.player.setVelocity(0, yChange, 0);
                        this.packetMove(0, yChange, 0);
                    }
                }
            }
        }
    }

    private void packetMove(double x, double y, double z) {
        PacketUtil.sendPacketNoEvent(new CPacketPlayer.Position(mc.player.posX + x, mc.player.posY + y, mc.player.posZ + z, mc.player.onGround));
        PacketUtil.sendPacketNoEvent(new CPacketPlayer.Position(mc.player.posX + x, -1337, mc.player.posZ + z, mc.player.onGround));

        this.teleportID++;
        mc.player.connection.sendPacket(new CPacketConfirmTeleport(this.teleportID - 1));
        mc.player.connection.sendPacket(new CPacketConfirmTeleport(this.teleportID));
        mc.player.connection.sendPacket(new CPacketConfirmTeleport(this.teleportID + 1));
    }

    private boolean playerIsMoving() {
        return mc.gameSettings.keyBindJump.isKeyDown() || mc.gameSettings.keyBindSneak.isKeyDown() || mc.gameSettings.keyBindJump.isKeyDown() || mc.gameSettings.keyBindForward.isKeyDown() || mc.gameSettings.keyBindLeft.isKeyDown() || mc.gameSettings.keyBindSneak.isKeyDown() || mc.gameSettings.keyBindRight.isKeyDown() || mc.gameSettings.keyBindBack.isKeyDown();
    }

    @EventSubscribe
    public void onReceivePacket(ReceivePacketEvent event) {
        if (event.getPacket() instanceof SPacketPlayerPosLook) {
            final SPacketPlayerPosLook packet = (SPacketPlayerPosLook) event.getPacket();
            if (!(mc.player.isEntityAlive() && mc.world.isBlockLoaded(new BlockPos(mc.player.posX, mc.player.posY, mc.player.posZ)) && !(mc.currentScreen instanceof GuiDownloadTerrain)))
                return;

            if (this.teleportID <= 0) this.teleportID = packet.getTeleportId();
            else event.cancel();
        }
    }

    @EventSubscribe
    public void onPacket(SendPacketEvent event) {
        if (event.getPacket() instanceof CPacketPlayer && !(event.getPacket() instanceof CPacketPlayer.Position || event.getPacket() instanceof CPacketPlayer.PositionRotation)) {
            event.cancel();
        }
    }

    private enum Mode {
        NEG_CLIP_1,
    }
}
