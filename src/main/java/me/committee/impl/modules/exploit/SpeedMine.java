package me.committee.impl.modules.exploit;

import me.committee.api.eventsystem.annotation.EventSubscribe;
import me.committee.api.module.Module;
import me.committee.api.setting.Setting;
import me.committee.api.util.MathUtil;
import me.committee.api.util.RenderUtil;
import me.committee.impl.event.events.player.PlayerDamageBlockEvent;
import me.committee.impl.event.events.player.PlayerUpdateEvent;
import me.committee.impl.event.events.render.Render3DEvent;
import net.minecraft.block.Block;
import net.minecraft.block.BlockAir;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.init.Blocks;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;

import java.awt.*;
import java.util.HashSet;

public class SpeedMine extends Module {

    private final Setting<Boolean> breakQueue = new Setting<>("BreakQueue", new String[]{"MultiMine", "MultiBreak", "MineOrder", "MineQueue", "BreakOrder"}, "Click multiple blocks to add them to the break queue.", false);
    private final Setting<Boolean> handAnimations = new Setting<>("HandAnimations", new String[]{"Animations", "Anim", "HandAnim"}, "If enabled it will show the hand animations for breaking the blocks.", false);
    private final Setting<Boolean> instaBreak = new Setting<>("InstaBreak", new String[]{"InstantBreak", "Instant"}, "If break queue is off, this will allow you to instantly re-break the block.", true);
    private final Setting<Float> range = new Setting<>("Range", new String[]{"R", "Distance", "Dist"}, "The range that you can click blocks.", 4.0f, 0.1f, 10.0f, 0.1f);

    private final Block[] disallowedBlocks = new Block[] {Blocks.BEDROCK, Blocks.END_PORTAL_FRAME, Blocks.WATER, Blocks.FLOWING_WATER, Blocks.LAVA, Blocks.FLOWING_LAVA, Blocks.PORTAL, Blocks.END_PORTAL, Blocks.END_PORTAL_FRAME, Blocks.END_GATEWAY, Blocks.AIR};

    private HashSet<BlockToBreak> blockPositions;
    private BlockToBreak blockBreaking;

    public SpeedMine() {
        super("SpeedMine", new String[]{"FastMine"}, "Allows you to mine faster.", Category.EXPLOIT);
    }

    @Override
    public void onEnable() {
        super.onEnable();
        this.blockPositions = new HashSet<>();
        this.blockBreaking = null;
    }

    @EventSubscribe
    public void onPlayerDamageBlock(PlayerDamageBlockEvent event) {
        event.setCancelled(true);

        final BlockToBreak blockToBreak = new BlockToBreak(event.getBlockPos(), event.getEnumFacing());

        if (this.validBlock(event.getBlockPos())) {
            if (this.breakQueue.getValue()) this.blockPositions.add(blockToBreak);
            else this.blockBreaking = blockToBreak;
        }
    }

    @EventSubscribe
    public void onPlayerUpdate(PlayerUpdateEvent event) {
        if (this.breakQueue.getValue()) {
            if (this.blockBreaking == null) {
                this.blockPositions.removeIf(blockToBreak -> !this.validBlock(blockToBreak.getBlockPos()) || !validDistance(blockToBreak.getBlockPos()));
                this.blockBreaking = blockPositions.stream().findFirst().orElse(null);
            }
        }

        if (this.blockBreaking != null) {
            if (!this.validBlock(this.blockBreaking.getBlockPos())) {
                final BlockPos blockPos = this.blockBreaking.getBlockPos();
                this.blockPositions.remove(this.blockBreaking);
                this.blockBreaking.setBrokenBefore(true);
                if (!this.breakQueue.getValue() &&
                        this.instaBreak.getValue() &&
                        mc.world.getBlockState(blockPos).getBlock() instanceof BlockAir &&
                        mc.player.getDistance(blockPos.getX(), blockPos.getY(), blockPos.getZ()) <= 30
                )
                    return;
                this.blockBreaking = null;
                return;
            }

            this.destroyBlock(this.blockBreaking);
        }
    }

    @EventSubscribe
    public void onRender3D(Render3DEvent event) {
        if (this.breakQueue.getValue())
            for (BlockToBreak blockPosition : this.blockPositions)
                RenderUtil.renderBlock(blockPosition.getBlockPos(), Color.ORANGE.hashCode());

        if (this.blockBreaking != null)
            RenderUtil.renderBlock(blockBreaking.getBlockPos(), Color.RED.hashCode());
    }

    private void destroyBlock(BlockToBreak blockToBreak) {
        if (!blockToBreak.hasBrokenBefore())
            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, blockToBreak.getBlockPos(), blockToBreak.getEnumFacing()));
        mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, blockToBreak.getBlockPos(), blockToBreak.getEnumFacing()));
        if (this.handAnimations.getValue()) mc.player.swingArm(EnumHand.MAIN_HAND);
    }



    private boolean validBlock(BlockPos blockPos) {
        final Block block = mc.world.getBlockState(blockPos).getBlock();

        for (Block disallowedBlock : this.disallowedBlocks) {
            if (disallowedBlock == block)
                return false;
        }
        return true;
    }

    private boolean validDistance(BlockPos blockPos) {
        return mc.player.getDistance(blockPos.getX(), blockPos.getY(), blockPos.getZ()) <= this.range.getValue();
    }

    public static class BlockToBreak {

        private final BlockPos blockPos;
        private final EnumFacing enumFacing;
        private boolean brokenBefore;

        public BlockToBreak(BlockPos blockPos, EnumFacing enumFacing) {
            this.blockPos = blockPos;
            this.enumFacing = enumFacing;
            this.brokenBefore = false;
        }

        public BlockPos getBlockPos() {
            return blockPos;
        }

        public EnumFacing getEnumFacing() {
            return enumFacing;
        }

        public boolean hasBrokenBefore() {
            return brokenBefore;
        }

        public void setBrokenBefore(boolean brokenBefore) {
            this.brokenBefore = brokenBefore;
        }

    }

}
